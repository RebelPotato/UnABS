# Unlambda at breakneck speed

## A simple evaluator

We represent unlambda terms as atoms. The only operator is `:app`. The functions are `s`, `k`, `i`, `v`, `{:dot, char}`, `d`, and `c`. We can also add `r` `g` (reset and go).

```elixir
defmodule Eval1 do
  def eval(:i), do: {:i}
  def eval(:s), do: {:s}
  def eval(:k), do: {:k}
  def eval(:v), do: {:v}
  def eval(:d), do: {:d}
  # def eval(:c), do: {:c}   # after the CPS transform

  def eval({:app, t0, t1}) do
    v = eval(t0)
    case v do
      {:d} -> {:d, t1}
      {:d, t0} -> eval({:app, t0, t1})
      _ ->
        w = eval(t1)
        case v do
          {:i} -> w
          {:s} -> {:s, w}
          {:s, w0} -> {:s, w0, w}
          {:s, w0, w1} -> throw("unimplemented")
          # apply the values together, like eval({:app, {:app, w0, w}, {:app, w1, w}})
          {:k} -> {:k, w}
          {:k, w} -> w
          {:v} -> {:v}
        end
    end
  end

  def main(t), do: eval(t)
end
```

```elixir
k = :k
i = :i
Eval1.main({:app, {:app, k, i}, k})
```

Yeah, it works. Note that it is almost an abstract machine now! Then CPS transform it...

```elixir
defmodule Eval2 do
  def eval(:i, k), do: k.({:i})
  def eval(:s, k), do: k.({:s})
  def eval(:k, k), do: k.({:k})
  def eval(:v, k), do: k.({:v})
  def eval(:d, k), do: k.({:d})
  def eval(:c, k), do: k.({:c})   # added after the CPS transform
  def eval({:put, c}, k) do
    IO.puts(c)
    k.({:i})
  end

  def eval({:app, t0, t1}, k) do
    eval(t0, fn v ->
      case v do
        {:d} -> k.({:d, t1})
        {:s} -> k.({:s, t1})
        {:s, st0} -> k.({:s, st0, t1})
        {:s, st0, st1} -> 
          eval({:app, st0, t1}, fn w0 -> 
            eval({:app, st1, t1}, fn w1 -> 
              app(w0, w1, k)
            end)
          end)
        _ -> eval(t1, fn w -> app(v, w, k) end)
      end
    end)
  end
  
  def app(v, w, k) do
    case v do
      {:i} -> k.(w)
      {:k} -> k.({:k, w})
      {:k, w} -> k.(w)
      {:v} -> k.({:v})
      {:c} -> app(w, {:c, k}, k)
      {:c, k1} -> k1.(w)
      {:d, t0} -> eval(t0, fn w0 -> app(w0, w, k) end)
    end
  end
  
  def main(t), do: eval(t, fn k -> k end)
end
```

```elixir
Eval2.main({:app, {:app, {:app, :s, :d}, {:app, :k, :k}}, :i})
```

Now defunctionalize the kontinuations.

```elixir
defmodule Eval3 do
  def eval(:i, k), do: applyK(k, {:i})
  def eval(:s, k), do: applyK(k, {:s})
  def eval(:k, k), do: applyK(k, {:k})
  def eval(:v, k), do: applyK(k, {:v})
  def eval(:d, k), do: applyK(k, {:d})
  def eval(:c, k), do: applyK(k, {:c})
  def eval({:put, c}, k), do: applyK(k, {:put, c})

  def eval({:app, t0, t1}, k) do
    eval(t0, {:bindT, t1, k})
  end

  def applyT(v, t, k) do
    case v do
      {:d} -> applyK(k, {:d, t})
      {:s} -> applyK(k, {:s, t})
      {:s, t0} -> applyK(k, {:s, t0, t})
      {:s, t0, t1} -> eval({:app, t0, t}, {:s2, t1, t, k})
      _ -> eval(t, {:bindV, v, k})
    end
  end
  
  def applyV(v, w, k) do
    case v do
      {:i} -> applyK(k, w)
      {:put, c} -> 
        IO.inspect(c)
        applyK(k, w)
      {:k} -> applyK(k, {:k, w})
      {:k, w} -> applyK(k, w)
      {:v} -> applyK(k, {:v})
      {:c} -> applyV(w, {:c, k}, k)
      {:c, k1} -> applyK(k1, w)
      {:d, t0} -> eval(t0, {:bindW, w, k})
    end
  end

  def applyK(:return, v), do: v
  def applyK({:bindT, t, k}, v), do: applyT(v, t, k)
  def applyK({:bindV, v, k}, w), do: applyV(v, w, k)
  def applyK({:bindW, w, k}, v), do: applyV(v, w, k)
  def applyK({:s2, t1, t, k}, v), do: eval({:app, t1, t}, {:s1, v, k}) 
  def applyK({:s1, v, k}, w), do: applyV(v, w, k)
  
  def main(t), do: eval(t, :return)
end
```

```elixir
Eval3.main({:app, {:app, {:app, :s, :d}, {:app, :k, :k}}, :i})
```

And we've arrived at an abstract machine! But to make this a virtual machine, we need to do more work.

(an abstract machine operates on a syntax tree, while a virtual machine operates on a flat list.)

<!-- livebook:{"break_markdown":true} -->

First make it compositional and curried.

Compositional means that each evaluated term must come from the arguments, not from a stored argument.

After currying, the eval function returns a function that accepts a kontinution.

```elixir
defmodule Eval4 do
  def eval(:i), do: fn k -> applyK(k, {:i}) end
  def eval(:s), do: fn k -> applyK(k, {:s}) end
  def eval(:k), do: fn k -> applyK(k, {:k}) end
  def eval(:v), do: fn k -> applyK(k, {:v}) end
  def eval(:d), do: fn k -> applyK(k, {:d}) end
  def eval(:c), do: fn k -> applyK(k, {:c}) end
  def eval({:put, c}), do: fn k -> applyK(k, {:put, c}) end

  def eval({:app, t0, t1}) do
    fn k ->
      eval(t0).({:bindT, t1, k})
    end
  end

  def applyT(v) do
    fn(t, k) ->
      case v do
        {:d} -> applyK(k, {:d, t})
        _ -> eval(t).({:bindV, v, k})
      end
    end
  end
  
  def applyV(v) do
    fn(w, k) ->
      case v do
        {:i} -> applyK(k, w)
        {:put, c} -> 
          IO.inspect(c)
          applyK(k, w)
        {:s} -> applyK(k, {:s, w})
        {:s, w0} -> applyK(k, {:s, w0, w})
        {:s, w0, w1} -> applyV(w0).(w, {:s2, w1, w, k})
        {:k} -> applyK(k, {:k, w})
        {:k, w} -> applyK(k, w)
        {:v} -> applyK(k, {:v})
        {:c} -> applyV(w).({:c, k}, k)
        {:c, k1} -> applyK(k1, w)
        {:d, t0} -> eval(t0).({:bindW, w, k})
      end
    end
  end

  def applyK(:return, v), do: v
  def applyK({:bindT, t, k}, v), do: applyT(v).(t, k)
  def applyK({:bindV, v, k}, w), do: applyV(v).(w, k)
  def applyK({:bindW, w, k}, v), do: applyV(v).(w, k)
  # potentially parallel! but doing this requires two kontinuation stacks.
  # fibers!
  def applyK({:s2, w1, w, k}, l), do: applyV(w1).(w, {:s1, l, k}) 
  def applyK({:s1, l, k}, r), do: applyV(l).(r, k)
  
  def main(t), do: eval(t).(:return)
end
```

```elixir
Eval3.main({:app, {:app, {:app, :s, :d}, {:app, :c, :k}}, :i})
```
