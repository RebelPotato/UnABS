# Unlambda at breakneck speed

## A simple evaluator

We represent unlambda terms as atoms. The only operator is `:app`. The functions are `s`, `k`, `i`, `v`, `{:dot, char}`, `d`, and `c`. We can also add `r` `g` (reset and go).

```elixir
defmodule Eval1 do
  
  def eval({:app, t0, t1}) do
    v = eval(t0)
    case v do
      {:d} -> {:d, t1}
      {:d, t0} -> eval({:app, t0, t1})
      {:i} -> eval(t1)
      {:s} -> {:s, eval(t1)}
      {:s, v0} -> {:s, v0, eval(t1)}
      {:s, v0, v1} -> eval({:app, {:app, t0, t1}, {:app, t00, t1}})
      {:k} -> {:k, eval(t1)}
      {:k, t} -> t
      {:v} -> {:v}
    end
  end
  def eval(x), do: x
  
  def main(t), do: eval(t)
end
```

```elixir
k = {:k}
i = {:i}
Eval1.main({:app, {:app, k, i}, k})
```

Yeah, it works. Note that it is almost an abstract machine now! Then CPS transform it...

```elixir
defmodule Eval2 do
  
  def eval({:app, t0, t1}, k) do
    eval(t0, fn v ->
      case v do
        {:d} -> k.({:d, t1})
        {:d, t0} -> eval({:app, t0, t1}, k)
        {:i} -> eval(t1, k)
        {:s} -> k.({:s, t1})
        {:s, t0} -> k.({:s, t0, t1})
        {:s, t0, t00} -> eval({:app, {:app, t0, t1}, {:app, t00, t1}}, k)
        {:k} -> k.({:k, v})
        {:k, t} -> eval(t, k)
        {:v} -> k.({:v})
      end  
    end)
  end
  def eval(x, k), do: k.(x)
  
  def main(t), do: eval(t, fn x -> x end)
end
```

```elixir
Eval2.main({:app, {:app, {:app, {:s}, {:d}}, {:app, {:k}, {:k}}}, {:i}})
```

Now defunctionalize the kontinuations.

```elixir
defmodule Eval3 do
  def eval(:i, k), do: applyK(k, {:i})
  def eval(:s, k), do: applyK(k, {:s})
  def eval(:k, k), do: applyK(k, {:k})
  def eval(:v, k), do: applyK(k, {:v})
  def eval(:d, k), do: applyK(k, {:d})
  def eval(:c, k), do: applyK(k, {:c})
  def eval({:put, c}, k), do: applyK(k, {:put, c})

  def eval({:app, t0, t1}, k) do
    eval(t0, {:bindT, t1, k})
  end

  def applyT(v, t, k) do
    case v do
      {:d} -> applyK(k, {:d, t})
      {:s} -> applyK(k, {:s, t})
      {:s, t0} -> applyK(k, {:s, t0, t})
      {:s, t0, t1} -> eval({:app, t0, t}, {:s2, t1, t, k})
      _ -> eval(t, {:bindV, v, k})
    end
  end
  
  def applyV(v, w, k) do
    case v do
      {:i} -> applyK(k, w)
      {:put, c} -> 
        IO.inspect(c)
        applyK(k, w)
      {:k} -> applyK(k, {:k, w})
      {:k, w} -> applyK(k, w)
      {:v} -> applyK(k, {:v})
      {:c} -> applyV(w, {:c, k}, k)
      {:c, k1} -> applyK(k1, w)
      {:d, t0} -> eval(t0, {:bindW, w, k})
    end
  end

  def applyK(:return, v), do: v
  def applyK({:bindT, t, k}, v), do: applyT(v, t, k)
  def applyK({:bindV, v, k}, w), do: applyV(v, w, k)
  def applyK({:bindW, w, k}, v), do: applyV(v, w, k)
  def applyK({:s2, t1, t, k}, v), do: eval({:app, t1, t}, {:s1, v, k}) 
  def applyK({:s1, v, k}, w), do: applyV(v, w, k)
  
  def main(t), do: eval(t, :return)
end
```

```elixir
Eval3.main({:app, {:app, {:app, :s, :d}, {:app, :k, :k}}, :i})
```

And we've arrived at an abstract machine! But to make this a virtual machine, we need to do more work.

(an abstract machine operates on a syntax tree, while a virtual machine operates on a flat list.)

<!-- livebook:{"break_markdown":true} -->

First make it compositional and curried.

Compositional means that each evaluated term must come from the arguments, not from a stored argument.

After currying, the eval function returns a function that accepts a kontinution.

```elixir
defmodule Eval4 do
  def eval(:i), do: applyK({:i})
  def eval(:s), do: applyK({:s}) 
  def eval(:k), do: applyK({:k}) 
  def eval(:v), do: applyK({:v}) 
  def eval(:d), do: applyK({:d})
  def eval(:c), do: applyK({:c})
  def eval({:put, c}), do: applyK({:put, c}) 

  def eval({:app, t0, t1}) do
    fn k ->
      eval(t0).({:bindT, t1, k})
    end
  end
  def applyT(v, t, k) do
    case v do
      {:d} -> applyK({:d, t}).(k)
      {:s} -> applyK({:s, {:recur, eval(t)}}).(k)
      {:s, {:recur, c0}} -> applyK({:s, {:recur, c0}, {:recur, eval(t)}}).(k)
      {:s, {:recur, c0}, {:recur, c1}} -> c0.({:bindT, t, {:s2, {:recur, c1}, t, k}})
      _ -> eval(t).({:bindV, v, k})
    end
  end
  
  def applyV(v, w, k) do
    case v do
      {:i} -> applyK(w).(k)
      {:put, c} -> 
        IO.inspect(c)
        applyK(w).(k)
      {:k} -> applyK({:k, w}).(k)
      {:k, w} -> applyK(w).(k)
      {:v} -> applyK({:v}).(k)
      {:c} -> applyV(w, {:c, k}, k)
      {:c, k1} -> applyK(w).(k1)
      {:d, t0} -> eval(t0).({:bindW, w, k})
    end
  end

  def applyK(v) do
    fn k -> applyK1(k, v) end
  end

  def applyK1(:return, v), do: v
  def applyK1({:bindT, t, k}, v), do: applyT(v, t, k)
  def applyK1({:bindV, v, k}, w), do: applyV(v, w, k)
  def applyK1({:bindW, w, k}, v), do: applyV(v, w, k)
  def applyK1({:s2, {:recur, c1}, t, k}, v), do: c1.({:bindT, t, {:s1, v, k}}) 
  def applyK1({:s1, v, k}, w), do: applyV(v, w, k)
  
  def main(t), do: eval(t).(:return)
end
```

```elixir
Eval4.main({:app, {:app, {:app, :s, :d}, {:app, :c, :k}}, :i})
```

After this, we can extract all functions

```elixir
# defmodule Ops do
 
#   def value({:going, k}) do
#     applyK(k, )
#   end
#   def value({:done}), do: {:done}
# end

defmodule Eval5 do

  defmodule Ops do
    def lift(f) do
      fn x -> 
        case x do
          {:going, x} -> f.(x)
          {:done} -> {:done}
        end
      end
    end
    
    def combine(f, g) do
      fn x -> g.(f.(x)) end
    end
    
    def push(t1) do
      lift(fn k -> {:going, {:bindT, t1, k}} end)
    end
  end
  
  def eval(:i), do: applyK({:i})
  def eval(:s), do: applyK({:s}) 
  def eval(:k), do: applyK({:k}) 
  def eval(:v), do: applyK({:v}) 
  def eval(:d), do: applyK({:d})
  def eval(:c), do: applyK({:c})
  def eval({:put, c}), do: applyK({:put, c}) 

  def eval({:app, t0, t1}) do
    Ops.combine(Ops.push(t1), eval(t0))
  end

  def applyT(v, t, k) do
    case v do
      {:d} -> applyK({:d, t}).(k)
      {:s} -> applyK({:s, {:recur, eval(t)}}).(k)
      {:s, {:recur, c0}} -> applyK({:s, {:recur, c0}, {:recur, eval(t)}}).(k)
      {:s, {:recur, c0}, {:recur, c1}} -> c0.({:bindT, t, {:s2, {:recur, c1}, t, k}})
      _ -> eval(t).({:bindV, v, k})
    end
  end
  
  def applyV(v, w, k) do
    case v do
      {:i} -> applyK(w).(k)
      {:put, c} -> 
        IO.inspect(c)
        applyK(w).(k)
      {:k} -> applyK({:k, w}).(k)
      {:k, w} -> applyK(w).(k)
      {:v} -> applyK({:v}).(k)
      {:c} -> applyV(w, {:c, k}, k)
      {:c, k1} -> applyK(w).(k1)
      {:d, t0} -> eval(t0).({:bindW, w, k})
    end
  end

  def applyK(v) do
    fn k -> applyK1(k, v) end
  end

  def applyK1(:return, v), do: v
  def applyK1({:bindT, t, k}, v), do: applyT(v, t, k)
  def applyK1({:bindV, v, k}, w), do: applyV(v, w, k)
  def applyK1({:bindW, w, k}, v), do: applyV(v, w, k)
  def applyK1({:s2, {:recur, c1}, t, k}, v), do: c1.({:bindT, t, {:s1, v, k}}) 
  def applyK1({:s1, v, k}, w), do: applyV(v, w, k)
  
  def main(t), do: eval(t).(:return)
end
```

```elixir
Eval5.main({:app, {:app, {:app, :s, :d}, {:app, :c, :k}}, :i})
```
